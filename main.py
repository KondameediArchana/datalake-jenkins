# Author Name : Chidarapu Gopi Krishna
# Edits & Review: Kalyan Gande

from fastapi import FastAPI, Depends, HTTPException, status
from utilities import kafka_producer, get_token, get_dag_data
import logging
from logging.handlers import TimedRotatingFileHandler
import os
import requests
from requests.auth import HTTPBasicAuth
from trino_utilities import get_next_uri_from_db, forward_request_to_trino, store_next_uri, forward_next_uri_to_trino, get_mongo_collection

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Get the base directory where the script is located
base_path = os.path.dirname(os.path.abspath(__file__))

# Define the log file path within the "logs" directory
log_file = os.path.join(base_path, "logs", "api_server.log")

# Ensure the "logs" folder exists
log_folder = os.path.dirname(log_file)
if not os.path.exists(log_folder):
    os.makedirs(log_folder)
    
# Add a rotating file handler
file_handler = TimedRotatingFileHandler(log_file, when="midnight", interval=1, backupCount=5)
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.addHandler(file_handler)

console_handler = logging.StreamHandler()
console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.addHandler(console_handler)


airflow_api_url = os.getenv("AIRFLOW_API_URL", "http://localhost:8080/api")
airflow_username = os.getenv("AIRFLOW_USERNAME","admin")
airflow_password = os.getenv("AIRFLOW_PASSWORD","admin")

app = FastAPI()

@app.post("/user-login")
def get_access_token(data: dict = Depends(get_token)):
    """
    Endpoint to retrieve the access token from the dependency function.
    
    Parameters:
        - data: dict - The access token retrieved from the dependency function.

    Returns:
        - str: The access token.
    
    Raises:
        - HTTPException: If access token is missing or invalid, returns 401 Unauthorized.
    """
    if not data.get("access_token"):
        error_message = data.get("error", "Access token is missing or invalid")
        logger.error(f"Error accured while user trying to logged in {error_message}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=error_message,
            headers={"WWW-Authenticate": "Bearer"},
        )
    logger.info("User logged in successfully and get access_token")
    return data["access_token"]

@app.post("/submit-job")
def send_request_to_kafka(request_id: dict = Depends(kafka_producer)):
    """
    Endpoint to send a job request to Kafka and return the request ID.

    Parameters:
        - request_id: dict - The request ID generated by the Kafka producer.

    Returns:
        - dict: The request ID.
    """
    logger.info("Send data to Kafka API was triggered successfully")
    return request_id

@app.get("/job/{request_id}")
def get_job_status(data = Depends(get_dag_data)):
    """
    Endpoint to get the status of a job using the request ID.

    Parameters:
        - job_status: Dependency - The job status retrieved from the dependency function.

    Returns:
        - dict: The job status.
    """
    try:
        if data.get("dag_id") and data.get("run_id"):
            dag_id = data["dag_id"]
            run_id = data["run_id"]
            endpoint = f"{airflow_api_url}/v1/dags/{dag_id}/dagRuns/{run_id}"
            response = requests.get(endpoint,auth=HTTPBasicAuth(airflow_username, airflow_password))

            if response.status_code == 200:
                json_response = response.json()
                status = json_response["state"]
                return {"message": status}
            elif response.status_code == 404:
                json_response = response.json()
                message = json_response.get("detail", "No detail found")
                raise HTTPException(
                    status_code=404,
                    detail=message,
                )
            else:
                raise HTTPException(
                    status_code=401,
                    detail="Unauthorized",
                    headers={"WWW-Authenticate": "Basic"},
                )    
        else:
            return data
    except Exception as e:
        return {"error":e}



@app.delete("/job/{request_id}")
def stop_airflow_job(data: dict = Depends(get_dag_data)):
    """
    Endpoint to stop an Airflow job using the provided data.

    Parameters:
        - data: dict - The data required to stop the Airflow job.

    Returns:
        - dict: Success message if the job is stopped successfully.

    Raises:
        - HTTPException: If there is an error stopping the job (e.g., unauthorized, not found).
    """
    try:
        if data.get("dag_id") and data.get("run_id"):
            dag_id = data["dag_id"]
            run_id = data["run_id"]
            endpoint = f"{airflow_api_url}/v1/dags/{dag_id}/dagRuns/{run_id}"
            response = requests.delete(endpoint,auth=HTTPBasicAuth(airflow_username, airflow_password))

            if response.status_code == 204:
                return {"message": f"Successfully stopped Airflow job."}
            elif response.status_code == 404:
                json_response = response.json()
                message = json_response.get("detail", "No detail found")
                raise HTTPException(
                    status_code=404,
                    detail=message,
                )
                
            else:
                raise HTTPException(
                    status_code=401,
                    detail="Unauthorized",
                    headers={"WWW-Authenticate": "Basic"},
                )    
        else:
            return data
    except Exception as e:
        return {"error":e}
    
@app.post("/execute_query/")
async def execute_query(query: str = None):
    try:
        if not query:
            raise Exception("Query should not be empty")
 
        logger.info(f"Executing query: {query}")
 
        trino_response = forward_request_to_trino(query)
        response_data = trino_response
 
        if 'nextUri' in response_data:
            page_token = store_next_uri(response_data['nextUri'])
            response_data['nextUri'] = f"http://127.0.0.1:8000/fetch_page/{page_token}"
 
        return response_data
 
    except Exception as e:
        logger.error(f"Error executing query: {str(e)}")
        raise HTTPException(status_code=200, detail=f": {str(e)}")
 
@app.get("/fetch_page/{page_token}")
async def fetch_page(page_token: str):
    try:
        trino_next_uri = get_next_uri_from_db(page_token)
        if trino_next_uri:
            response_data = forward_next_uri_to_trino(trino_next_uri)
 
            if 'nextUri' in response_data:
                new_page_token = store_next_uri(response_data['nextUri'])
                response_data['nextUri'] = f"http://127.0.0.1:8000/fetch_page/{new_page_token}"
 
                filter_criteria = {"token": page_token}
                update_operation = {"$set": {"tokenUsed": True}}
                collection = get_mongo_collection()
                collection.update_one(filter_criteria, update_operation)
 
                return response_data
 
        else:
            raise HTTPException(status_code=404, detail="The URL you have given was already used.")
 
    except Exception as e:
        logger.error(f"Error fetching page: {str(e)}")
        raise HTTPException(status_code=200, detail=f"{str(e)}")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)
